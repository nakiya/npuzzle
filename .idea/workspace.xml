<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="9139fa2d-6f47-42ac-9fd0-f9f56c65dd4b" name="Default" comment="">
      <change beforePath="$PROJECT_DIR$/.idea/npuzzle.iml" afterPath="$PROJECT_DIR$/.idea/npuzzle.iml" />
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" afterPath="$PROJECT_DIR$/.idea/workspace.xml" />
      <change beforePath="$PROJECT_DIR$/README.md" afterPath="$PROJECT_DIR$/README.md" />
      <change beforePath="$PROJECT_DIR$/figwheel_server.log" afterPath="$PROJECT_DIR$/figwheel_server.log" />
      <change beforePath="$PROJECT_DIR$/src/clj/npuzzle/puzzle.clj" afterPath="$PROJECT_DIR$/src/clj/npuzzle/puzzle.clj" />
    </list>
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="TRACKING_ENABLED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileEditorManager">
    <leaf SIDE_TABS_SIZE_LIMIT_KEY="300">
      <file leaf-file-name="project.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/project.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="0">
              <caret line="51" column="11" lean-forward="false" selection-start-line="51" selection-start-column="11" selection-end-line="51" selection-end-column="11" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="handler.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/clj/npuzzle/handler.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="195">
              <caret line="26" column="0" lean-forward="false" selection-start-line="26" selection-start-column="0" selection-end-line="26" selection-end-column="0" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core.cljs" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/core.cljs">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="150">
              <caret line="10" column="25" lean-forward="false" selection-start-line="10" selection-start-column="25" selection-end-line="10" selection-end-column="25" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="views.cljs" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/views.cljs">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="345">
              <caret line="23" column="0" lean-forward="false" selection-start-line="23" selection-start-column="0" selection-end-line="23" selection-end-column="0" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="puzzle.clj" pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/src/clj/npuzzle/puzzle.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="855">
              <caret line="90" column="40" lean-forward="true" selection-start-line="90" selection-start-column="40" selection-end-line="90" selection-end-column="40" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="db.cljs" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/db.cljs">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="0">
              <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="events.cljs" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/events.cljs">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="0">
              <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="subs.cljs" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/subs.cljs">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="390">
              <caret line="26" column="19" lean-forward="false" selection-start-line="26" selection-start-column="19" selection-end-line="26" selection-end-column="19" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="ClojureScript Namespace" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="GradleLocalSettings">
    <option name="externalProjectsViewState">
      <projects_view />
    </option>
  </component>
  <component name="IdeDocumentHistory">
    <option name="CHANGED_PATHS">
      <list>
        <option value="$PROJECT_DIR$/test/cljs/npuzzle/runner.cljs" />
        <option value="$PROJECT_DIR$/LICENSE" />
        <option value="$PROJECT_DIR$/src/clj/npuzzle/css.clj" />
        <option value="$PROJECT_DIR$/README.md" />
        <option value="$PROJECT_DIR$/resources/public/index.html" />
        <option value="$PROJECT_DIR$/test/cljs/npuzzle/db_test.cljs" />
        <option value="$PROJECT_DIR$/src/cljs/npuzzle/subs.cljs" />
        <option value="$PROJECT_DIR$/src/cljs/npuzzle/events.cljs" />
        <option value="$PROJECT_DIR$/src/cljs/npuzzle/views.cljs" />
        <option value="$PROJECT_DIR$/src/cljs/npuzzle/pmap.cljs" />
        <option value="$PROJECT_DIR$/src/cljs/npuzzle/db.cljs" />
        <option value="$PROJECT_DIR$/project.clj" />
        <option value="$PROJECT_DIR$/src/clj/npuzzle/puzzle.clj" />
      </list>
    </option>
  </component>
  <component name="ProjectFrameBounds" fullScreen="true">
    <option name="width" value="1680" />
    <option name="height" value="1050" />
  </component>
  <component name="ProjectView">
    <navigator currentView="ProjectPane" proportions="" version="1">
      <flattenPackages />
      <showMembers />
      <showModules />
      <showLibraryContents />
      <hideEmptyPackages />
      <abbreviatePackageNames />
      <autoscrollToSource />
      <autoscrollFromSource />
      <sortByType />
      <manualOrder />
      <foldersAlwaysOnTop value="true" />
    </navigator>
    <panes>
      <pane id="Scratches" />
      <pane id="ProjectPane">
        <subPane>
          <expand>
            <path>
              <item name="npuzzle" type="b2602c69:ProjectViewProjectNode" />
              <item name="npuzzle" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="npuzzle" type="b2602c69:ProjectViewProjectNode" />
              <item name="npuzzle" type="462c0819:PsiDirectoryNode" />
              <item name="resources" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="npuzzle" type="b2602c69:ProjectViewProjectNode" />
              <item name="npuzzle" type="462c0819:PsiDirectoryNode" />
              <item name="resources" type="462c0819:PsiDirectoryNode" />
              <item name="public" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="npuzzle" type="b2602c69:ProjectViewProjectNode" />
              <item name="npuzzle" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="npuzzle" type="b2602c69:ProjectViewProjectNode" />
              <item name="npuzzle" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="clj" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="npuzzle" type="b2602c69:ProjectViewProjectNode" />
              <item name="npuzzle" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="clj" type="462c0819:PsiDirectoryNode" />
              <item name="npuzzle" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="npuzzle" type="b2602c69:ProjectViewProjectNode" />
              <item name="npuzzle" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="cljs" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="npuzzle" type="b2602c69:ProjectViewProjectNode" />
              <item name="npuzzle" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="cljs" type="462c0819:PsiDirectoryNode" />
              <item name="npuzzle" type="462c0819:PsiDirectoryNode" />
            </path>
          </expand>
          <select />
        </subPane>
      </pane>
      <pane id="AndroidView" />
      <pane id="PackagesPane" />
      <pane id="Scope" />
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="settings.editor.selected.configurable" value="project.propVCSSupport.Mappings" />
    <property name="project.structure.last.edited" value="Project" />
    <property name="project.structure.proportion" value="0.15" />
    <property name="project.structure.side.proportion" value="0.0" />
    <property name="cursive.last.file.extension./Users/duminda/dev/personal/npuzzle/src/cljs" value="cljs" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
  </component>
  <component name="RecentsManager">
    <key name="CopyFile.RECENT_KEYS">
      <recent name="$PROJECT_DIR$/src/clj/npuzzle" />
      <recent name="$PROJECT_DIR$/test/cljs/npuzzle" />
      <recent name="$PROJECT_DIR$/src/cljs/npuzzle" />
      <recent name="$PROJECT_DIR$" />
    </key>
  </component>
  <component name="ReplState" timestamp="1519913090558">{:repl-history {:ide [], :local [{:command &quot;(reduce (fn [a b]\n            (when a\n                  (let [zp (.indexOf a 0)\n                        num (get b zp)]\n                       num)))\n        (vec path))&quot;, :offset 169, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;path&quot;, :offset 4, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(vec path)&quot;, :offset 10, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(.indexOf path 0)&quot;, :offset 17, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(.indexOf path [5 1 4 6 7 3 8 2 0])&quot;, :offset 35, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(.indexOf (get path 0) 0)&quot;, :offset 25, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(get path 0)&quot;, :offset 12, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(defn solve [start dim]\n  (let [closed #{}\n        f-start (heuristic start dim)\n        open (make-mm [[f-start {:puzzle start :parent nil :g 0 :f f-start}]])]\n    (if-let [path (A* open closed dim)]\n      (reduce (fn [a b]\n                  (let [zp (.indexOf a 0)\n                        num (get b zp)]\n                      num))\n        (vec path)))))&quot;, :offset 357, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn solve [start dim]\n  (let [closed #{}\n        f-start (heuristic start dim)\n        open (make-mm [[f-start {:puzzle start :parent nil :g 0 :f f-start}]])]\n    (if-let [path (A* open closed dim)]\n      path)))&quot;, :offset 214, :ns &quot;npuzzle.db&quot;} {:command &quot;(vec [1 2 3])&quot;, :offset 13, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(defn to-actions [path]\n  (let [vpath (vec path)]\n    (reduce #(let [zp (.indexOf 0 %1)\n                   num (get %2 zp)]\n               num)\n      vpath)))&quot;, :offset 158, :ns &quot;npuzzle.db&quot;} {:command &quot;(reduce #(vec [%1 %2]) *1)&quot;, :offset 26, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(reduce #(conj %1 %2 *1))&quot;, :offset 25, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(reduce #(conj %1 %2) *1)&quot;, :offset 25, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(defn to-actions [path]\n  (let [p1 (vec path)\n        p2 (conj (pop path) (peek path))]\n    [p1 p2]))&quot;, :offset 101, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn to-actions [path]\n  (let [p1 (vec path)\n        p2 (conj (pop p1) (peek p1))]\n    [p1 p2]))&quot;, :offset 97, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn to-actions [path]\n  (let [p1 (vec path)\n        p2 (into [(first p1)] (pop p1))] \n    [p1 p2]))&quot;, :offset 101, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn to-actions [path]\n  (let [p1 (vec path)\n        p2 (into [(first p1)] (pop p1))]\n    (map #(get (.indexOf %1 0) %2) p2 p1)))&quot;, :offset 130, :ns &quot;npuzzle.db&quot;} {:command &quot;(def rp [5 1 4 6 7 3 8 2 0])&quot;, :offset 28, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(solve rp 3)&quot;, :offset 12, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(to-actions *1)&quot;, :offset 15, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(defn to-actions [path]\n  (let [p1 (vec path)\n        p2 (into [(first p1)] (pop p1))]\n    (map #(get %2 (.indexOf %1 0)) p2 p1)))&quot;, :offset 130, :ns &quot;npuzzle.db&quot;} {:command &quot;(to-actions (solve [5 1 4 6 7 3 8 2 0] 3))&quot;, :offset 42, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(defn solve [start dim]\n  (let [closed #{}\n        f-start (heuristic start dim)\n        open (make-mm [[f-start {:puzzle start :parent nil :g 0 :f f-start}]])]\n    (if-let [path (A* open closed dim)]\n      (let [p1 (vec path)\n            p2 (into [(first p1)] (pop p1))]\n        (rest (map #(get %2 (.indexOf %1 0)) p2 p1))))))&quot;, :offset 328, :ns &quot;npuzzle.db&quot;} {:command &quot;(str \&quot;What \&quot; [1 2 3])&quot;, :offset 21, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(defn config-panel []\n  (let [dim (re-frame/subscribe [::subs/dimension])\n        solution (re-frame/subscribe [::subs/solution])]\n      [:div.row\n        [:div.col-sm-12.m-1\n          [:label {:for \&quot;dim_select\&quot;} \&quot;Select dimension\&quot;]\n          [:select#dim_select.form-control.mt-10\n            {:value @dim\n             :placeholder \&quot;Select dimension\&quot;\n             :on-change #(re-frame/dispatch [:npuzzle.events/change-dimension\n                                             (int (-&gt; % .-target .-value))])}\n            [:option {:value 3} \&quot;3x3\&quot;]\n            [:option {:value 4} \&quot;4x4\&quot;]\n            [:option {:value 5} \&quot;5x5\&quot;]\n            [:option {:value 6} \&quot;6x6\&quot;]]]\n        [:div.col-sm-12.m-1\n          [:button.btn.btn-primary {:type :button\n                                    :on-click #(re-frame/dispatch [:npuzzle.events/shuffle])}\n           \&quot;Shuffle\&quot;]]\n       [:div.col-sm-12.m-1\n          [:label (str \&quot;Solution: \&quot; @solution)]\n          [:button.btn.btn-primary {:type :button\n                                    :on-click #(re-frame/dispatch [:npuzzle.events/solve])}\n           \&quot;Solve\&quot;]]]))&quot;, :offset 1101, :ns &quot;npuzzle.views&quot;} {:command &quot;(defn- A* [open closed dim]\n  (when (not (empty? open))\n    (let [[key node] (first-multi open)\n          puzzle (first node)]\n      [key node]\n      (if (solved? (first node))\n        (reverse (create-path node []))\n        (let [open (dissoc-multi open (nth node 3) node)\n              closed (conj closed puzzle)\n              neighbors (get-neighbors puzzle dim)]\n          (recur\n            (reduce\n              (fn [coll neighbor]\n                (let [g (+ 1 (nth node 2))\n                      f (+ g (heuristic neighbor dim))]\n                   (assoc-multi coll f [neighbor node g f])))\n              open\n              (map #(when (nil? (get closed %)) %)\n                neighbors))\n            closed\n            dim))))))&quot;, :offset 738, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A* [open open-inv closed dim]\n  (when (not (empty? open))\n    (let [[_ node] (first-multi open)\n          puzzle (first node)]\n      (if (solved? (first node))\n        (reverse (create-path node []))\n        (let [open (dissoc-multi open (nth node 3) node)\n              open-inv (dissoc open-inv (first node))\n              closed (conj closed puzzle)\n              neighbors (get-neighbors puzzle dim)]\n          (recur\n            (reduce\n              (fn [coll neighbor]\n                (let [g (+ 1 (nth node 2))\n                      f (+ g (heuristic neighbor dim))]\n                   (assoc-multi coll f [neighbor node g f])))\n              open\n              (map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n                neighbors))\n            (reduce #(conj %1 %2)\n                    closed\n                    (map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n                         neighbors))\n            closed\n            dim))))))&quot;, :offset 997, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A* [open open-inv closed dim]\n  (when (not (empty? open))\n    (let [[_ node] (first-multi open)\n          puzzle (first node)]\n      (if (solved? (first node))\n        (reverse (create-path node []))\n        (let [open (dissoc-multi open (nth node 3) node)\n              open-inv (dissoc open-inv (first node))\n              closed (conj closed puzzle)\n              neighbors (get-neighbors puzzle dim)]\n          (recur\n            (reduce\n              (fn [coll neighbor]\n                (let [g (+ 1 (nth node 2))\n                      f (+ g (heuristic neighbor dim))]\n                   (assoc-multi coll f [neighbor node g f])))\n              open\n              (map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n                neighbors))\n            (reduce #(conj %1 %2)\n                    open-inv\n                    (map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n                         neighbors))\n            closed\n            dim))))))&quot;, :offset 999, :ns &quot;npuzzle.db&quot;} {:command &quot;(conj [1] nil)&quot;, :offset 14, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(defn- A* [open open-inv closed dim]\n  (when (not (empty? open))\n    (let [[_ node] (first-multi open)\n          puzzle (first node)]\n      (if (solved? (first node))\n        (reverse (create-path node []))\n        (let [open (dissoc-multi open (nth node 3) node)\n              open-inv (dissoc open-inv (first node))\n              closed (conj closed puzzle)\n              neighbors (get-neighbors puzzle dim)]\n          (recur\n            (reduce\n              (fn [coll neighbor]\n                (let [g (+ 1 (nth node 2))\n                      f (+ g (heuristic neighbor dim))]\n                   (assoc-multi coll f [neighbor node g f])))\n              open\n              (map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n                neighbors))\n            (reduce #(if (nil? %2) %1 (conj %1 %2))\n                    open-inv\n                    (map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n                         neighbors))\n            closed\n            dim))))))&quot;, :offset 1017, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A* [open open-inv closed dim]\n  (do\n    (when (&lt; (count open) 10)\n      (println open))\n    (when (not (empty? open))\n      (let [[_ node] (first-multi open)\n            puzzle (first node)]\n        (if (solved? (first node))\n          (reverse (create-path node []))\n          (let [open (dissoc-multi open (nth node 3) node)\n                open-inv (dissoc open-inv (first node))\n                closed (conj closed puzzle)\n                neighbors (get-neighbors puzzle dim)]\n            (recur\n              (reduce\n                (fn [coll neighbor]\n                  (let [g (+ 1 (nth node 2))\n                        f (+ g (heuristic neighbor dim))]\n                     (assoc-multi coll f [neighbor node g f])))\n                open\n                (map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n                  neighbors))\n              (reduce #(if (nil? %2) %1 (conj %1 %2))\n                      open-inv\n                      (map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n                           neighbors))\n              closed\n              dim)))))))&quot;, :offset 1124, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A* [open open-inv closed dim]\n  (do\n    (when (&lt; (count open) 10)\n      (println open))\n    (when (not (empty? open))\n      (let [[_ node] (first-multi open)\n            puzzle (first node)]\n        (if (solved? (first node))\n          (reverse (create-path node []))\n          (let [open (dissoc-multi open (nth node 3) node)\n                open-inv (disj open-inv (first node))\n                closed (conj closed puzzle)\n                neighbors (get-neighbors puzzle dim)]\n            (recur\n              (reduce\n                (fn [coll neighbor]\n                  (let [g (+ 1 (nth node 2))\n                        f (+ g (heuristic neighbor dim))]\n                     (assoc-multi coll f [neighbor node g f])))\n                open\n                (map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n                  neighbors))\n              (reduce #(if (nil? %2) %1 (conj %1 %2))\n                      open-inv\n                      (map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n                           neighbors))\n              closed\n              dim)))))))&quot;, :offset 1122, :ns &quot;npuzzle.db&quot;} {:command &quot;#{[1 2 3]}&quot;, :offset 10, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(defn- A* [open open-inv closed dim]\n  (do\n    (when (&lt; (count open) 100)\n      (println open))\n    (when (not (empty? open))\n      (let [[_ node] (first-multi open)\n            puzzle (first node)]\n        (if (solved? (first node))\n          (reverse (create-path node []))\n          (let [open (dissoc-multi open (nth node 3) node)\n                open-inv (disj open-inv (first node))\n                closed (conj closed puzzle)\n                neighbors (get-neighbors puzzle dim)]\n            (recur\n              (reduce\n                (fn [coll neighbor]\n                  (let [g (+ 1 (nth node 2))\n                        f (+ g (heuristic neighbor dim))]\n                     (assoc-multi coll f [neighbor node g f])))\n                open\n                (map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n                  neighbors))\n              (reduce #(if (nil? %2) %1 (conj %1 %2))\n                      open-inv\n                      (map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n                           neighbors))\n              closed\n              dim)))))))&quot;, :offset 1123, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A* [open open-inv closed dim]\n  (when (not (empty? open))\n    (let [[_ node] (first-multi open)\n          puzzle (first node)]\n      (if (solved? (first node))\n        (reverse (create-path node []))\n        (let [open (dissoc-multi open (nth node 3) node)\n              open-inv (disj open-inv (first node))\n              closed (conj closed puzzle)\n              neighbors (get-neighbors puzzle dim)]\n          (recur\n            (reduce\n              (fn [coll neighbor]\n                (let [g (+ 1 (nth node 2))\n                      f (+ g (heuristic neighbor dim))]\n                   (assoc-multi coll f [neighbor node g f])))\n              open\n              (filter\n                #(not (nil? %))\n                (map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n                  neighbors)))\n            (reduce #(if (nil? %2) %1 (conj %1 %2))\n                    open-inv\n                    (filter\n                      #(not (nil? %))\n                      (map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n                           neighbors)))\n            closed\n            dim))))))&quot;, :offset 1145, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A* [open closed dim]\n  (when (not (empty? open))\n    (let [[_ node] (first-multi open)\n          puzzle (first node)]\n      (if (solved? (first node))\n        (reverse (create-path node []))\n        (let [open (dissoc-multi open (nth node 3) node)\n              open-inv (disj open-inv (first node))\n              closed (conj closed puzzle)\n              neighbors (get-neighbors puzzle dim)]\n          (recur\n            (reduce\n              (fn [coll neighbor]\n                (let [g (+ 1 (nth node 2))\n                      f (+ g (heuristic neighbor dim))]\n                   (assoc-multi coll f [neighbor node g f])))\n              open\n              (filter\n                #(not (nil? %))\n                (map #(when (nil? (get closed %)) %) \n                ;(map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n                  neighbors)))\n            ;(reduce #(if (nil? %2) %1 (conj %1 %2))\n            ;        open-inv\n            ;        (filter\n            ;          #(not (nil? %))\n            ;          (map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n            ;               neighbors)))\n            closed\n            dim))))))&quot;, :offset 1197, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A* [open closed dim]\n  (when (not (empty? open))\n    (let [[_ node] (first-multi open)\n          puzzle (first node)]\n      (if (solved? (first node))\n        (reverse (create-path node []))\n        (let [open (dissoc-multi open (nth node 3) node)\n              ;open-inv (disj open-inv (first node))\n              closed (conj closed puzzle)\n              neighbors (get-neighbors puzzle dim)]\n          (recur\n            (reduce\n              (fn [coll neighbor]\n                (let [g (+ 1 (nth node 2))\n                      f (+ g (heuristic neighbor dim))]\n                   (assoc-multi coll f [neighbor node g f])))\n              open\n              (filter\n                #(not (nil? %))\n                (map #(when (nil? (get closed %)) %) \n                ;(map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n                  neighbors)))\n            ;(reduce #(if (nil? %2) %1 (conj %1 %2))\n            ;        open-inv\n            ;        (filter\n            ;          #(not (nil? %))\n            ;          (map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n            ;               neighbors)))\n            closed\n            dim))))))&quot;, :offset 1198, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A* [open closed dim]\n  (do\n    (when (&lt; (count open) 100)\n      (println open))\n    (when (not (empty? open))\n      (let [[_ node] (first-multi open)\n            puzzle (first node)]\n        (if (solved? (first node))\n          (reverse (create-path node []))\n          (let [open (dissoc-multi open (nth node 3) node)\n                ;open-inv (disj open-inv (first node))\n                closed (conj closed puzzle)\n                neighbors (get-neighbors puzzle dim)]\n            (recur\n              (reduce\n                (fn [coll neighbor]\n                  (let [g (+ 1 (nth node 2))\n                        f (+ g (heuristic neighbor dim))]\n                     (assoc-multi coll f [neighbor node g f])))\n                open\n                (filter\n                  #(not (nil? %))\n                  (map #(when (nil? (get closed %)) %)\n                  ;(map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n                    neighbors)))\n              ;(reduce #(if (nil? %2) %1 (conj %1 %2))\n              ;        open-inv\n              ;        (filter\n              ;          #(not (nil? %))\n              ;          (map #(when (and (nil? (get closed %)) (nil? (get open-inv %)) %))\n              ;               neighbors)))\n              closed\n              dim)))))))&quot;, :offset 1315, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A* [open closed dim]\n  (do\n    (when (&lt; (count open) 10)\n      (println open))\n    (when (not (empty? open))\n      (let [[_ node] (first-multi open)\n            puzzle (first node)]\n        (if (solved? (first node))\n          (reverse (create-path node []))\n          (let [open (dissoc-multi open (nth node 3) node)\n                closed (conj closed puzzle)\n                neighbors (get-neighbors puzzle dim)]\n            (recur\n              (reduce\n                (fn [coll neighbor]\n                  (let [g (+ 1 (nth node 2))\n                        f (+ g (heuristic neighbor dim))]\n                    (assoc-multi coll f [neighbor node g f])))\n                open\n                (filter\n                  #(not (nil? %))\n                  (map #(when (nil? (get closed %)) %)\n                       neighbors)))\n              closed\n              dim)))))))&quot;, :offset 881, :ns &quot;npuzzle.db&quot;} {:command &quot;(solve [5 1 4 6 7 3 8 2 0] 3)&quot;, :offset 29, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted open-set closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[key current] (first-multi open-sorted)]\n      (if (solved? current)\n        current\n        (let [neighbors (filter #(nil? (get closed-set %)) (get-neighbors current dim))\n              current-g (current g-scores)\n              open-sorted (dissoc-multi open-sorted key current)\n              open-set (disj open-set current)\n              closed-set (conj closed-set current)]\n          {:neighbors neighbors :open-sorted open-sorted\n           :open-set open-set :closed-set closed-set\n           :current-g current-g})))))&quot;, :offset 649, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted open-set closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[key current] (first-multi open-sorted)]\n      (if (solved? current)\n        current\n        (let [neighbors (filter #(nil? (get closed-set %)) (get-neighbors current dim))\n              ;current-g (current g-scores)\n              open-sorted (dissoc-multi open-sorted key current)\n              open-set (disj open-set current)\n              closed-set (conj closed-set current)]\n          {:neighbors neighbors :open-sorted open-sorted\n           :open-set open-set :closed-set closed-set\n           :current-g current-g})))))&quot;, :offset 650, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted open-set closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[key current] (first-multi open-sorted)]\n      (if (solved? current)\n        current\n        (let [neighbors (filter #(nil? (get closed-set %)) (get-neighbors current dim))\n              ;current-g (current g-scores)\n              open-sorted (dissoc-multi open-sorted key current)\n              open-set (disj open-set current)\n              closed-set (conj closed-set current)]\n          {:neighbors neighbors :open-sorted open-sorted\n           :open-set open-set :closed-set closed-set})))))&quot;, :offset 618, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted open-set closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[key current] (first-multi open-sorted)]\n      (if (solved? current)\n        current\n        (let [neighbors (filter #(nil? (get closed-set %)) (get-neighbors current dim))\n              ;current-g (current g-scores)\n              open-sorted (dissoc-multi open-sorted key current)\n              open-set (disj open-set current)\n              closed-set (conj closed-set current)]\n          {:neighbors neighbors :open-sorted open-sorted\n           :open-set open-set :closed-set closed-set\n           :g-scores g-scores :f-scores f-scores :came-from came-from})))))&quot;, :offset 688, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted open-set closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[key current] (first-multi open-sorted)]\n      (if (solved? current)\n        current\n        (let [neighbors (filter #(nil? (get closed-set %)) (get-neighbors current dim))\n              current-g (current g-scores)\n              open-sorted (dissoc-multi open-sorted key current)\n              open-set (disj open-set current)\n              closed-set (conj closed-set current)]\n          {:neighbors neighbors :open-sorted open-sorted\n           :open-set open-set :closed-set closed-set\n           :g-scores g-scores :f-scores f-scores :came-from came-from\n           :current-g current-g})))))&quot;, :offset 719, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn solve2 [start dim]\n  (let [closed-set #{}\n        open-set #{start}\n        h (heuristic start dim)\n        g-scores {start 0}\n        f-scores {start h}\n        open-sorted (make-mm [[h start]])\n        came-from {start nil}]\n    (A*2 open-sorted open-set closed-set g-scores f-scores came-from dim)))&quot;, :offset 308, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted open-set closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[key current] (first-multi open-sorted)]\n      (if (solved? current)\n        current\n        (let [neighbors (filter #(nil? (get closed-set %)) (get-neighbors current dim))\n              current-g (get g-scores current)\n              open-sorted (dissoc-multi open-sorted key current)\n              open-set (disj open-set current)\n              closed-set (conj closed-set current)]\n          {:neighbors neighbors :open-sorted open-sorted\n           :open-set open-set :closed-set closed-set\n           :g-scores g-scores :f-scores f-scores :came-from came-from\n           :current-g current-g})))))&quot;, :offset 723, :ns &quot;npuzzle.db&quot;} {:command &quot;(pmap/priority-map :c 5 :b 2 :a 7)&quot;, :offset 34, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;*1&quot;, :offset 2, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(def pm *1)&quot;, :offset 11, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(peek pm)&quot;, :offset 9, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(pop pm)&quot;, :offset 8, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              neighbors (filter #(nil? (get closed-set %)) (get-neighbors current dim))\n              current-g (get g-scores current)\n              open-sorted (pop open-sorted)]\n          {:neighbors neighbors :open-sorted open-sorted\n           :open-set open-set :closed-set closed-set\n           :g-scores g-scores :f-scores f-scores :came-from came-from\n           :current-g current-g})))))&quot;, :offset 637, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn solve2 [start dim]\n  (let [closed-set #{}\n        open-set #{start}\n        h (heuristic start dim)\n        g-scores {start 0}\n        f-scores {start h}\n        open-sorted (pmap/priority-map start h)\n        came-from {start nil}]\n    (A*2 open-sorted closed-set g-scores f-scores came-from dim)))&quot;, :offset 305, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current))))&quot;, :offset 192, :ns &quot;npuzzle.db&quot;} {:command &quot;(pmap/priority-map :a 2 :b 1 :c 3 :d 5 :e 4 :f 3)&quot;, :offset 49, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(into (pmap/priority-map) [[0 1 2 3] 4])&quot;, :offset 40, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(into (pmap/priority-map) [[[0 1 2 3] 4]])&quot;, :offset 42, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(defn solve2 [start dim]\n  (let [closed-set #{}\n        h (heuristic start dim)\n        g-scores {start 0}\n        f-scores {start h}\n        open-sorted (into (pmap/priority-map) [[start h]])\n        came-from {start nil}]\n    (A*2 open-sorted closed-set g-scores f-scores came-from dim)))&quot;, :offset 290, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        current))))&quot;, :offset 208, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              neighbors (filter #(nil? (get closed-set %)) (get-neighbors current dim))\n              current-g (get g-scores current)\n              open-sorted (pop open-sorted)]\n          {:neighbors neighbors :open-sorted open-sorted\n           :closed-set closed-set\n           :g-scores g-scores :f-scores f-scores :came-from came-from\n           :current-g current-g})))))&quot;, :offset 618, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(and (nil? (get closed-set %)) (nil? (get open-sorted %))) \n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          {:neighbors neighbors :open-sorted open-sorted\n           :closed-set closed-set\n           :g-scores g-scores :f-scores f-scores :came-from came-from\n           :current-g current-g})))))&quot;, :offset 684, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-soted (reduce #(assoc %1 %2 (heuristic %2 dim)) open-sorted neighbors)]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 752, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-sorted (reduce #(assoc %1 %2 (heuristic %2 dim)) open-sorted neighbors)]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 753, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn get-neighbors [puzzle dim]\n  (when puzzle\n    (let [zp (.indexOf puzzle 0)\n          zr (quot zp dim)\n          zc (mod zp dim)]\n      (map\n        (fn [[row col]]\n           (let [np (+ (* row dim) col)\n                 num (get puzzle np)]\n             (-&gt; puzzle\n                 (assoc np 0)\n                 (assoc zp num))))\n        (filter #(not (nil? %))\n          (map\n            (fn [dr dc]\n              (when (and (&lt; -1 (+ zr dr) dim) (&lt; -1 (+ zc dc) dim))\n                [(+ zr dr) (+ zc dc)]))\n            [-1 0 1 0]\n            [0 1 0 -1]))))))&quot;, :offset 567, :ns &quot;npuzzle.db&quot;} {:command &quot;(get-neighbors [5 1 4 6 7 3 8 2 0] 3)&quot;, :offset 37, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(reduce #(assoc %1 %2 (+ %2 50)) {} [1 2 3 4 5])&quot;, :offset 48, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(reduce #(if (even? %2) (assoc %1 %2 (+ %2 50)) %1) {} [1 2 3 4 5])&quot;, :offset 67, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-sorted (reduce #(assoc %1 %2 (heuristic %2 dim)) open-sorted neighbors)\n                tentative-g-scores (map #(+ 1 current-g) neighbors)\n                g-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1017, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-sorted (reduce #(assoc %1 %2 (heuristic %2 dim)) open-sorted neighbors)\n                tentative-g-scores (map #(+ 1 current-g) neighbors)\n                g-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (filter #(&gt;= %1 %2) (map #(vec [%1 %2 %3]) tentative-g-scores g-scores neighbors))]))))))&quot;, :offset 872, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-sorted (reduce #(assoc %1 %2 (heuristic %2 dim)) open-sorted neighbors)\n                tentative-g-scores (map #(+ 1 current-g) neighbors)\n                g-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (filter #(&gt;= %1 %2) (map #(vec [%1 %2 %3]) tentative-g-scores g-scores neighbors))]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1126, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-sorted (reduce #(assoc %1 %2 (heuristic %2 dim)) open-sorted neighbors)\n                tentative-g-scores (map #(+ 1 current-g) neighbors)\n                g-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (filter #(&lt; %1 %2) (map #(vec [%1 %2 %3]) tentative-g-scores g-scores neighbors))]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1125, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-sorted (reduce #(assoc %1 %2 (heuristic %2 dim)) open-sorted neighbors)\n                tentative-g-scores (map #(+ 1 current-g) neighbors)\n                g-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (map #(vec [%1 %2 %3]) tentative-g-scores g-scores neighbors)]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1105, :ns &quot;npuzzle.db&quot;} {:command &quot;g&quot;, :offset 1, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-sorted (reduce #(assoc %1 %2 (heuristic %2 dim)) open-sorted neighbors)\n                tentative-g-scores (map #(+ 1 current-g) neighbors)\n                g-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (filter #(&lt; (first %) (second %))\n                            (map #(vec [%1 %2 %3]) tentative-g-scores g-scores neighbors))]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1168, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-sorted (reduce #(assoc %1 %2 (heuristic %2 dim)) open-sorted neighbors)\n                tentative-g-scores (map #(+ 1 current-g) neighbors)\n                g-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (-&gt;&gt; (map #(vec [%1 %2 %3]) tentative-g-scores g-scores neighbors)\n                               (filter #(&lt; (first %) (second %)))\n                               (map #(nth % 2)))]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1225, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-sorted (reduce #(assoc %1 %2 (heuristic %2 dim)) open-sorted neighbors)\n                tentative-g-scores (map #(+ 1 current-g) neighbors)\n                g-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (-&gt;&gt; (map #(vec [%1 %2 %3]) tentative-g-scores g-scores neighbors)\n                               (filter #(&lt; (first %) (second %))))]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1177, :ns &quot;npuzzle.db&quot;} {:command &quot;(let [a 1])&quot;, :offset 11, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(let [a 1 b 2 a 3] a)&quot;, :offset 21, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(let [a 1 b 2 a (* a a)])&quot;, :offset 25, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(let [a 3 b 2 a (* a a)])&quot;, :offset 25, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(let* [a 3 b 2 a (* a a)])&quot;, :offset 26, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-sorted (reduce #(assoc %1 %2 (heuristic %2 dim)) open-sorted neighbors)\n                tentative-g-scores (map #(+ 1 current-g) neighbors)\n                G-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (-&gt;&gt; (map #(hash-map :g %1 :gt %2 :puzzle %3)\n                                    tentative-g-scores G-scores neighbors)\n                               (filter #(&lt; (:g %) (:gt %))))\n                came-from (reduce #(assoc %1 (:puzzle %2) current) came-from neighbors)]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1313, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-sorted (reduce #(assoc %1 %2 (heuristic %2 dim)) open-sorted neighbors)\n                tentative-g-scores (map #(+ 1 current-g) neighbors)\n                G-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (-&gt;&gt; (map #(hash-map :gt %1 :g %2 :puzzle %3)\n                                    tentative-g-scores G-scores neighbors)\n                               (filter #(&lt; (:gt %) (:g %))))\n                came-from (reduce #(assoc %1 (:puzzle %2) current) came-from neighbors)\n                g-scores (reduce #(assoc %1 (:puzzle %2) (:gt %2)) g-scores)]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1390, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-sorted (reduce #(assoc %1 %2 (heuristic %2 dim)) open-sorted neighbors)\n                tentative-g-scores (map #(+ 1 current-g) neighbors)\n                G-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (-&gt;&gt; (map #(hash-map :gt %1 :g %2 :puzzle %3)\n                                    tentative-g-scores G-scores neighbors)\n                               (filter #(&lt; (:gt %) (:g %))))\n                came-from (reduce #(assoc %1 (:puzzle %2) current) came-from neighbors)\n                g-scores (reduce #(assoc %1 (:puzzle %2) (:gt %2)) g-scores neighbors)]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1400, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-sorted (reduce #(assoc %1 %2 (heuristic %2 dim)) open-sorted neighbors)\n                tentative-g-scores (map #(+ 1 current-g) neighbors)\n                G-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (-&gt;&gt; (map #(hash-map :gt %1 :g %2 :puzzle %3)\n                                    tentative-g-scores G-scores neighbors)\n                               (filter #(&lt; (:gt %) (:g %))))\n                came-from (reduce #(assoc %1 (:puzzle %2) current) came-from neighbors)\n                g-scores (reduce #(assoc %1 (:puzzle %2) (:gt %2)) g-scores neighbors)\n                f-scores (reduce #(assoc %1 (:puzzle %2) (+ (:gt %2) (heuristic (:puzzle %2) dim)))\n                                f-scores neighbors)]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1552, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-sorted (reduce #(assoc %1 %2 (+ current-g (heuristic %2 dim)) open-sorted neighbors))\n                tentative-g-scores (map #(+ 1 current-g) neighbors)\n                G-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (-&gt;&gt; (map #(hash-map :gt %1 :g %2 :puzzle %3)\n                                    tentative-g-scores G-scores neighbors)\n                               (filter #(&lt; (:gt %) (:g %))))\n                came-from (reduce #(assoc %1 (:puzzle %2) current) came-from neighbors)\n                g-scores (reduce #(assoc %1 (:puzzle %2) (:gt %2)) g-scores neighbors)\n                f-scores (reduce #(assoc %1 (:puzzle %2) (+ (:g %2) (heuristic (:puzzle %2) dim)))\n                                f-scores neighbors)]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1565, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-sorted (reduce #(assoc %1 %2 (+ current-g (heuristic %2 dim))) \n                                 open-sorted neighbors)\n                tentative-g-scores (map #(+ 1 current-g) neighbors)\n                G-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (-&gt;&gt; (map #(hash-map :gt %1 :g %2 :puzzle %3)\n                                    tentative-g-scores G-scores neighbors)\n                               (filter #(&lt; (:gt %) (:g %))))\n                came-from (reduce #(assoc %1 (:puzzle %2) current) came-from neighbors)\n                g-scores (reduce #(assoc %1 (:puzzle %2) (:gt %2)) g-scores neighbors)\n                f-scores (reduce #(assoc %1 (:puzzle %2) (+ (:g %2) (heuristic (:puzzle %2) dim)))\n                                f-scores neighbors)]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1599, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-sorted (reduce #(assoc %1 %2 (+ current-g (heuristic %2 dim)))\n                                 open-sorted neighbors)\n                tentative-g-scores (map #(+ 1 current-g) neighbors)\n                G-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (-&gt;&gt; (map #(hash-map :gt %1 :g %2 :puzzle %3)\n                                    tentative-g-scores G-scores neighbors)\n                               (filter #(&lt; (:gt %) (:g %))))\n                came-from (reduce #(assoc %1 (:puzzle %2) current) came-from neighbors)\n                g-scores (reduce #(assoc %1 (:puzzle %2) (:gt %2)) g-scores neighbors)\n                f-scores (reduce #(assoc %1 (:puzzle %2) (+ (:g %2) (heuristic (:puzzle %2) dim)))\n                                f-scores neighbors)]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1598, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-sorted (reduce #(assoc %1 %2 (+ current-g (heuristic %2 dim)))\n                                 open-sorted neighbors)\n                tentative-g-scores (map #(+ 1 current-g) neighbors)\n                G-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (-&gt;&gt; (map #(hash-map :gt %1 :g %2 :puzzle %3)\n                                    tentative-g-scores G-scores neighbors)\n                               (filter #(&lt; (:gt %) (:g %))))\n                came-from (reduce #(assoc %1 (:puzzle %2) current) came-from neighbors)\n                g-scores (reduce #(assoc %1 (:puzzle %2) (:gt %2)) g-scores neighbors)\n                f-scores (reduce #(assoc %1 (:puzzle %2) (+ (:gt %2) (heuristic (:puzzle %2) dim)))\n                                f-scores neighbors)]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1599, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [tentative-g-scores (map #(+ 1 current-g) neighbors)\n                G-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (-&gt;&gt; (map #(hash-map :gt %1 :g %2 :puzzle %3)\n                                    tentative-g-scores G-scores neighbors)\n                               (filter #(&lt; (:gt %) (:g %))))\n                came-from (reduce #(assoc %1 (:puzzle %2) current) came-from neighbors)\n                g-scores (reduce #(assoc %1 (:puzzle %2) (:gt %2)) g-scores neighbors)\n                f-scores (reduce #(assoc %1 (:puzzle %2) (+ (:gt %2) (heuristic (:puzzle %2) dim)))\n                            f-scores neighbors)\n                open-sorted (reduce #(assoc %1 %2 (+ current-g (heuristic %2 dim)))                \n                              open-sorted neighbors)]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1608, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [tentative-g-scores (map #(+ 1 current-g) neighbors)\n                G-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (-&gt;&gt; (map #(hash-map :gt %1 :g %2 :puzzle %3)\n                                    tentative-g-scores G-scores neighbors)\n                               (filter #(&lt; (:gt %) (:g %))))\n                came-from (reduce #(assoc %1 (:puzzle %2) current) came-from neighbors)\n                g-scores (reduce #(assoc %1 (:puzzle %2) (:gt %2)) g-scores neighbors)\n                f-scores (reduce #(assoc %1 (:puzzle %2) (+ (:gt %2) (heuristic (:puzzle %2) dim)))\n                            f-scores neighbors)\n                open-sorted (reduce #(assoc %1 %2 (+ current-g (heuristic %2 dim)))\n                              open-sorted neighbors)]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1592, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [open-sorted (reduce #(assoc %1 %2 (+ current-g (heuristic %2 dim)))\n                               open-sorted neighbors)\n                tentative-g-scores (map #(+ 1 current-g) neighbors)\n                G-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (-&gt;&gt; (map #(hash-map :gt %1 :g %2 :puzzle %3)\n                                    tentative-g-scores G-scores neighbors)\n                               (filter #(&lt; (:gt %) (:g %))))\n                came-from (reduce #(assoc %1 (:puzzle %2) current) came-from neighbors)\n                g-scores (reduce #(assoc %1 (:puzzle %2) (:gt %2)) g-scores neighbors)\n                f-scores (reduce #(assoc %1 (:puzzle %2) (+ (:gt %2) (heuristic (:puzzle %2) dim)))\n                                f-scores neighbors)]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1597, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [o-sorted (reduce #(assoc %1 %2 (+ current-g (heuristic %2 dim)))\n                               open-sorted neighbors)\n                tentative-g-scores (map #(+ 1 current-g) neighbors)\n                G-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (-&gt;&gt; (map #(hash-map :gt %1 :g %2 :puzzle %3)\n                                    tentative-g-scores G-scores neighbors)\n                               (filter #(&lt; (:gt %) (:g %))))\n                came-from (reduce #(assoc %1 (:puzzle %2) current) came-from neighbors)\n                g-scores (reduce #(assoc %1 (:puzzle %2) (:gt %2)) g-scores neighbors)\n                f-scores (reduce #(assoc %1 (:puzzle %2) (+ (:gt %2) (heuristic (:puzzle %2) dim)))\n                              f-scores neighbors)\n                open-sorted (reduce #(assoc %1 %2 (+ (:gt %2) (heuristic (:puzzle %2) dim)))\n                             open-sorted neighbors)]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1737, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        current\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [tentative-g-scores (map #(+ 1 current-g) neighbors)\n                G-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (-&gt;&gt; (map #(hash-map :gt %1 :g %2 :puzzle %3)\n                                    tentative-g-scores G-scores neighbors)\n                               (filter #(&lt; (:gt %) (:g %))))\n                came-from (reduce #(assoc %1 (:puzzle %2) current) came-from neighbors)\n                g-scores (reduce #(assoc %1 (:puzzle %2) (:gt %2)) g-scores neighbors)\n                f-scores (reduce #(assoc %1 (:puzzle %2) (+ (:gt %2) (heuristic (:puzzle %2) dim)))\n                              f-scores neighbors)\n                open-sorted (reduce #(assoc %1 %2 (+ (:gt %2) (heuristic (:puzzle %2) dim)))\n                             open-sorted neighbors)]\n            {:neighbors neighbors :open-sorted open-sorted\n             :closed-set closed-set\n             :g-scores g-scores :tentative-g-scores tentative-g-scores\n             :f-scores f-scores :came-from came-from\n             :current-g current-g}))))))&quot;, :offset 1602, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        (reconstruct-path came-from current)\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [tentative-g-scores (map #(+ 1 current-g) neighbors)\n                G-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                             neighbors)\n                neighbors (-&gt;&gt; (map #(hash-map :gt %1 :g %2 :puzzle %3)\n                                    tentative-g-scores G-scores neighbors)\n                               (filter #(&lt; (:gt %) (:g %))))\n                came-from (reduce #(assoc %1 (:puzzle %2) current) came-from neighbors)\n                g-scores (reduce #(assoc %1 (:puzzle %2) (:gt %2)) g-scores neighbors)\n                f-scores (reduce #(assoc %1 (:puzzle %2) (+ (:gt %2) (heuristic (:puzzle %2) dim)))\n                              f-scores neighbors)\n                open-sorted (reduce #(assoc %1 %2 (+ (:gt %2) (heuristic (:puzzle %2) dim)))\n                             open-sorted neighbors)]\n            (recur open-sorted closed-set g-scores f-scores came-from dim)))))))&quot;, :offset 1452, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (do\n    (println {:open-sorted open-sorted\n              :closed-set closed-set\n              :g-scores g-scores\n              :f-scores f-scores :came-from came-from})\n    (println)\n    (when (not (empty? open-sorted))\n      (let [[current _] (peek open-sorted)]\n        (if (solved? current)\n          (reconstruct-path came-from current)\n          (let [closed-set (conj closed-set current)\n                open-sorted (pop open-sorted)\n                neighbors (filter #(nil? (get closed-set %))\n                                  (get-neighbors current dim))\n                current-g (get g-scores current)]\n            (let [tentative-g-scores (map #(+ 1 current-g) neighbors)\n                  G-scores (map #(if-let [g (get g-scores %)]\n                                   g 1000000)\n                               neighbors)\n                  neighbors (-&gt;&gt; (map #(hash-map :gt %1 :g %2 :puzzle %3)\n                                      tentative-g-scores G-scores neighbors)\n                                 (filter #(&lt; (:gt %) (:g %))))\n                  came-from (reduce #(assoc %1 (:puzzle %2) current) came-from neighbors)\n                  g-scores (reduce #(assoc %1 (:puzzle %2) (:gt %2)) g-scores neighbors)\n                  f-scores (reduce #(assoc %1 (:puzzle %2) (+ (:gt %2) (heuristic (:puzzle %2) dim)))\n                                f-scores neighbors)\n                  open-sorted (reduce #(assoc %1 %2 (+ (:gt %2) (heuristic (:puzzle %2) dim)))\n                               open-sorted neighbors)]\n              (recur open-sorted closed-set g-scores f-scores came-from dim))))))))&quot;, :offset 1684, :ns &quot;npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (do\n    (println {:open-sorted open-sorted\n              :closed-set closed-set\n              :g-scores g-scores\n              :f-scores f-scores :came-from came-from})\n    (println)\n    (when (not (empty? open-sorted))\n      (let [[current _] (peek open-sorted)]\n        (if (solved? current)\n          (reconstruct-path came-from current)\n          (let [closed-set (conj closed-set current)\n                open-sorted (pop open-sorted)\n                neighbors (filter #(nil? (get closed-set %))\n                                  (get-neighbors current dim))\n                current-g (get g-scores current)]\n            (let [tentative-g-scores (map #(+ 1 current-g) neighbors)\n                  G-scores (map #(if-let [g (get g-scores %)]\n                                   g 1000000)\n                               neighbors)\n                  neighbors (-&gt;&gt; (map #(hash-map :gt %1 :g %2 :puzzle %3)\n                                      tentative-g-scores G-scores neighbors)\n                                 (filter #(&lt; (:gt %) (:g %))))\n                  came-from (reduce #(assoc %1 (:puzzle %2) current) came-from neighbors)\n                  g-scores (reduce #(assoc %1 (:puzzle %2) (:gt %2)) g-scores neighbors)\n                  f-scores (reduce #(assoc %1 (:puzzle %2) (+ (:gt %2) (heuristic (:puzzle %2) dim)))\n                                f-scores neighbors)\n                  open-sorted (reduce #(assoc %1 (:puzzle %2) (+ (:gt %2) (heuristic (:puzzle %2) dim)))\n                                 open-sorted neighbors)]\n              (recur open-sorted closed-set g-scores f-scores came-from dim))))))))&quot;, :offset 1696, :ns &quot;npuzzle.db&quot;} {:command &quot;(solve2 [5 1 4 6 7 3 8 2 0] 3)&quot;, :offset 30, :ns &quot;dev:npuzzle.db&quot;} {:command &quot;(defn- A*2 [open-sorted closed-set g-scores f-scores came-from dim]\n  (when (not (empty? open-sorted))\n    (let [[current _] (peek open-sorted)]\n      (if (solved? current)\n        (reconstruct-path came-from current)\n        (let [closed-set (conj closed-set current)\n              open-sorted (pop open-sorted)\n              neighbors (filter #(nil? (get closed-set %))\n                                (get-neighbors current dim))\n              current-g (get g-scores current)]\n          (let [tentative-g-scores (map #(+ 1 current-g) neighbors)\n                G-scores (map #(if-let [g (get g-scores %)]\n                                 g 1000000)\n                              neighbors)\n                neighbors (-&gt;&gt; (map #(hash-map :gt %1 :g %2 :puzzle %3)\n                                    tentative-g-scores G-scores neighbors)\n                               (filter #(&lt; (:gt %) (:g %))))\n                came-from (reduce #(assoc %1 (:puzzle %2) current) came-from neighbors)\n                g-scores (reduce #(assoc %1 (:puzzle %2) (:gt %2)) g-scores neighbors)\n                f-scores (reduce #(assoc %1 (:puzzle %2) (+ (:gt %2) (heuristic (:puzzle %2) dim)))\n                                 f-scores neighbors)\n                open-sorted (reduce #(assoc %1 (:puzzle %2) (+ (:gt %2) (heuristic (:puzzle %2) dim)))\n                                    open-sorted neighbors)]\n            (recur open-sorted closed-set g-scores f-scores came-from dim)))))))&quot;, :offset 1473, :ns &quot;npuzzle.db&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager">
    <configuration default="true" type="Applet" factoryName="Applet">
      <option name="HTML_USED" value="false" />
      <option name="WIDTH" value="400" />
      <option name="HEIGHT" value="300" />
      <option name="POLICY_FILE" value="$APPLICATION_HOME_DIR$/bin/appletviewer.policy" />
      <module />
    </configuration>
    <configuration default="true" type="Application" factoryName="Application">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <option name="MAIN_CLASS_NAME" />
      <option name="VM_PARAMETERS" />
      <option name="PROGRAM_PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="ENABLE_SWING_INSPECTOR" value="false" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <module name="" />
      <envs />
    </configuration>
    <configuration name="REPL" type="ClojureREPL" factoryName="Local">
      <setting name="replType" value="2" />
      <module name="npuzzle" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="script/repl.clj" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
    </configuration>
    <configuration default="true" type="JUnit" factoryName="JUnit">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="TEST_OBJECT" value="class" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="%MODULE_WORKING_DIR%" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <envs />
      <patterns />
    </configuration>
    <configuration default="true" type="Remote" factoryName="Remote">
      <option name="USE_SOCKET_TRANSPORT" value="true" />
      <option name="SERVER_MODE" value="false" />
      <option name="SHMEM_ADDRESS" value="javadebug" />
      <option name="HOST" value="localhost" />
      <option name="PORT" value="5005" />
    </configuration>
    <configuration default="true" type="TestNG" factoryName="TestNG">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="SUITE_NAME" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="GROUP_NAME" />
      <option name="TEST_OBJECT" value="CLASS" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="%MODULE_WORKING_DIR%" />
      <option name="OUTPUT_DIRECTORY" />
      <option name="ANNOTATION_TYPE" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <option name="USE_DEFAULT_REPORTERS" value="false" />
      <option name="PROPERTIES_FILE" />
      <envs />
      <properties />
      <listeners />
    </configuration>
    <configuration default="true" type="#org.jetbrains.idea.devkit.run.PluginConfigurationType" factoryName="Plugin">
      <module name="" />
      <option name="VM_PARAMETERS" value="-Xmx512m -Xms256m -XX:MaxPermSize=250m -ea" />
      <option name="PROGRAM_PARAMETERS" />
      <predefined_log_file id="idea.log" enabled="true" />
    </configuration>
  </component>
  <component name="ShelveChangesManager" show_recycled="false">
    <option name="remove_strategy" value="false" />
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="9139fa2d-6f47-42ac-9fd0-f9f56c65dd4b" name="Default" comment="" />
      <created>1519718250110</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1519718250110</updated>
    </task>
    <servers />
  </component>
  <component name="ToolWindowManager">
    <frame x="0" y="0" width="1680" height="1050" extended-state="0" />
    <editor active="true" />
    <layout>
      <window_info id="Palette" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.26607144" sideWeight="0.5" order="3" side_tool="true" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.192" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.14702381" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="UI Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="true" content_ui="tabs" />
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="2" side_tool="false" content_ui="combo" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
    </layout>
  </component>
  <component name="UnknownFeatures">
    <option featureType="com.intellij.fileTypeFactory" implementationName="*.css" />
  </component>
  <component name="VcsContentAnnotationSettings">
    <option name="myLimit" value="2678400000" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager />
    <watches-manager />
  </component>
  <component name="editorHistoryManager">
    <entry file="file://$PROJECT_DIR$/src/clj/npuzzle/handler.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="195">
          <caret line="13" column="0" lean-forward="false" selection-start-line="13" selection-start-column="0" selection-end-line="13" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/config.cljs" />
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/db.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="60">
          <caret line="4" column="0" lean-forward="false" selection-start-line="4" selection-start-column="0" selection-end-line="4" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/events.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="480">
          <caret line="32" column="0" lean-forward="false" selection-start-line="32" selection-start-column="0" selection-end-line="32" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/clj/npuzzle/server.clj" />
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="540">
          <caret line="36" column="22" lean-forward="false" selection-start-line="36" selection-start-column="22" selection-end-line="36" selection-end-column="22" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/views.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="720">
          <caret line="48" column="17" lean-forward="false" selection-start-line="48" selection-start-column="17" selection-end-line="48" selection-end-column="17" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/subs.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="405">
          <caret line="27" column="0" lean-forward="false" selection-start-line="27" selection-start-column="0" selection-end-line="27" selection-end-column="0" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/events.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="585">
          <caret line="39" column="46" lean-forward="false" selection-start-line="39" selection-start-column="46" selection-end-line="39" selection-end-column="46" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/db.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="1860">
          <caret line="124" column="43" lean-forward="false" selection-start-line="124" selection-start-column="43" selection-end-line="124" selection-end-column="43" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/views.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="720">
          <caret line="48" column="17" lean-forward="false" selection-start-line="48" selection-start-column="17" selection-end-line="48" selection-end-column="17" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/subs.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="405">
          <caret line="27" column="0" lean-forward="true" selection-start-line="27" selection-start-column="0" selection-end-line="27" selection-end-column="0" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/events.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="585">
          <caret line="39" column="46" lean-forward="false" selection-start-line="39" selection-start-column="46" selection-end-line="39" selection-end-column="46" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/db.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="1725">
          <caret line="115" column="23" lean-forward="false" selection-start-line="115" selection-start-column="23" selection-end-line="115" selection-end-column="23" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="240">
          <caret line="16" column="33" lean-forward="false" selection-start-line="16" selection-start-column="33" selection-end-line="16" selection-end-column="33" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/script/repl.clj" />
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/config.cljs" />
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/db.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="360">
          <caret line="24" column="8" lean-forward="true" selection-start-line="24" selection-start-column="8" selection-end-line="24" selection-end-column="8" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/LICENSE" />
    <entry file="file://$PROJECT_DIR$/Procfile">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="0">
          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/views.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="0">
          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/clj/npuzzle/handler.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="15">
          <caret line="1" column="22" lean-forward="false" selection-start-line="1" selection-start-column="22" selection-end-line="1" selection-end-column="22" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/clj/npuzzle/server.clj" />
    <entry file="file://$PROJECT_DIR$/README.md">
      <provider selected="true" editor-type-id="split-provider[text-editor;markdown-preview-editor]">
        <state split_layout="SPLIT">
          <first_editor relative-caret-position="0">
            <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
          </first_editor>
          <second_editor />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/.lein-failures" />
    <entry file="file://$PROJECT_DIR$/test/cljs/npuzzle/runner.cljs" />
    <entry file="file://$PROJECT_DIR$/resources/public/css/screen.css">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="30">
          <caret line="21" column="0" lean-forward="false" selection-start-line="21" selection-start-column="0" selection-end-line="21" selection-end-column="0" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/README.md">
      <provider selected="true" editor-type-id="split-provider[text-editor;markdown-preview-editor]">
        <state split_layout="SPLIT">
          <first_editor relative-caret-position="90">
            <caret line="6" column="0" lean-forward="true" selection-start-line="6" selection-start-column="0" selection-end-line="6" selection-end-column="0" />
          </first_editor>
          <second_editor />
        </state>
      </provider>
      <provider editor-type-id="text-editor">
        <state relative-caret-position="30">
          <caret line="2" column="0" lean-forward="true" selection-start-line="2" selection-start-column="0" selection-end-line="2" selection-end-column="0" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/LICENSE" />
    <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojurescript/1.9.908/clojurescript-1.9.908.jar!/cljs/core.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="455">
          <caret line="766" column="12" lean-forward="false" selection-start-line="766" selection-start-column="12" selection-end-line="766" selection-end-column="12" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/target/classes/npuzzle/handler$fn__2002.class" />
    <entry file="file://$PROJECT_DIR$/figwheel_server.log" />
    <entry file="file://$PROJECT_DIR$/Procfile">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="15">
          <caret line="1" column="0" lean-forward="false" selection-start-line="1" selection-start-column="0" selection-end-line="1" selection-end-column="0" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/cljs/npuzzle/db_test.cljs" />
    <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojurescript/1.9.908/clojurescript-1.9.908.jar!/cljs/core.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="325">
          <caret line="2049" column="6" lean-forward="false" selection-start-line="2049" selection-start-column="6" selection-end-line="2049" selection-end-column="6" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/script/repl.clj" />
    <entry file="file://$PROJECT_DIR$/src/clj/npuzzle/css.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="240">
          <caret line="16" column="0" lean-forward="false" selection-start-line="16" selection-start-column="0" selection-end-line="16" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/clj/npuzzle/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="0">
          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/clj/npuzzle/server.clj" />
    <entry file="file://$PROJECT_DIR$/resources/public/index.html" />
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/config.cljs" />
    <entry file="file://$PROJECT_DIR$/src/clj/npuzzle/handler.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="195">
          <caret line="26" column="0" lean-forward="false" selection-start-line="26" selection-start-column="0" selection-end-line="26" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="0">
          <caret line="51" column="11" lean-forward="false" selection-start-line="51" selection-start-column="11" selection-end-line="51" selection-end-column="11" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/db.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="0">
          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/core.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="150">
          <caret line="10" column="25" lean-forward="false" selection-start-line="10" selection-start-column="25" selection-end-line="10" selection-end-column="25" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/events.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="0">
          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/pmap.cljs" />
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/subs.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="390">
          <caret line="26" column="19" lean-forward="false" selection-start-line="26" selection-start-column="19" selection-end-line="26" selection-end-column="19" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/cljs/npuzzle/views.cljs">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="345">
          <caret line="23" column="0" lean-forward="false" selection-start-line="23" selection-start-column="0" selection-end-line="23" selection-end-column="0" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojure/1.9.0/clojure-1.9.0.jar!/clojure/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="325">
          <caret line="2852" column="6" lean-forward="false" selection-start-line="2852" selection-start-column="6" selection-end-line="2852" selection-end-column="6" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/clj/npuzzle/puzzle.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="855">
          <caret line="90" column="40" lean-forward="true" selection-start-line="90" selection-start-column="40" selection-end-line="90" selection-end-column="40" />
          <folding />
        </state>
      </provider>
    </entry>
  </component>
  <component name="masterDetails">
    <states>
      <state key="ArtifactsStructureConfigurable.UI">
        <settings>
          <artifact-editor />
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="FacetStructureConfigurable.UI">
        <settings>
          <last-edited>No facets are configured</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="GlobalLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="JdkListConfigurable.UI">
        <settings>
          <last-edited>IDE SDK</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ModuleStructureConfigurable.UI">
        <settings>
          <last-edited>npuzzle</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
                <option value="0.6" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectLibrariesConfigurable.UI">
        <settings>
          <last-edited>Leiningen: args4j:2.33</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
    </states>
  </component>
</project>